<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extractor Datos</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Importamos Inter (Cuerpo) y JetBrains Mono (Datos/Código) */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500&family=JetBrains+Mono:wght@400&display=swap');
        
        body { 
            font-family: 'Inter', sans-serif; 
            background: #ffffff; 
            color: #1a1a1a; /* Negro suave, no #000000 */
            height: 100vh; 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            font-weight: 300; /* Tipografía fina por defecto */
        }

        /* Scrollbar Ultra-Minimalista (Casi invisible) */
        ::-webkit-scrollbar { width: 4px; height: 4px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #e5e5e5; border-radius: 2px; }
        ::-webkit-scrollbar-thumb:hover { background: #d4d4d4; }

        /* Barra de carga: Fina y elegante */
        .loading-bar { 
            position: fixed; 
            top: 0; 
            left: 0; 
            height: 2px; 
            background: #1a1a1a; 
            transition: width 0.4s ease; 
            z-index: 1000; 
        }
        
        .font-mono { font-family: 'JetBrains Mono', monospace; letter-spacing: -0.02em; }

        /* Inputs: Sin bordes visibles hasta hover/focus, muy limpios */
        .config-input {
            background: transparent;
            border-bottom: 1px solid #e5e5e5;
            color: #1a1a1a;
            padding: 4px 0;
            border-radius: 0; 
            font-size: 0.75rem;
            outline: none;
            transition: border-color 0.3s;
        }
        .config-input:focus { border-bottom: 1px solid #1a1a1a; }

        /* Botones estilo nórdico: Solo texto y subrayado o fondo muy sutil */
        .btn-nordic { 
            background: #ffffff;
            color: #1a1a1a;
            text-transform: uppercase; 
            font-size: 10px;
            letter-spacing: 0.1em;
            font-weight: 500;
            border: 1px solid #e5e5e5;
            padding: 8px 16px;
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
        }
        .btn-nordic:hover { 
            border-color: #1a1a1a;
            background: #fff;
        }
        .btn-nordic:disabled {
            opacity: 0.4;
            cursor: default;
            border-color: #f0f0f0;
        }

        /* Botón de acción principal (Negro sólido, sin bordes) */
        .btn-primary {
            background: #1a1a1a;
            color: #ffffff;
            border: none;
            font-family: 'Inter', sans-serif;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.15em;
            padding: 16px;
            transition: opacity 0.3s;
        }
        .btn-primary:hover { opacity: 0.8; }
        .btn-primary:disabled { background: #e5e5e5; color: #a3a3a3; }

        /* Utilidades de texto */
        .label-text {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            color: #9ca3af; /* Gris claro */
            font-weight: 500;
        }

        /* Animación suave para logs */
        .log-enter { animation: fadeSlide 0.4s ease forwards; opacity: 0; }
        @keyframes fadeSlide { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
    </style>
</head>
<body>

    <div id="loading-bar" class="loading-bar" style="width: 0%"></div>

    <div id="folder-modal" class="fixed inset-0 z-[100] flex items-center justify-center bg-white/95 p-8 hidden transition-opacity">
        <div class="bg-white w-full max-w-lg flex flex-col max-h-[60vh] border border-gray-200">
            <div class="p-6 border-b border-gray-100 flex justify-between items-center">
                <h2 class="text-xs font-medium tracking-[0.2em] text-gray-400 uppercase">Seleccionar Destino</h2>
                <button onclick="document.getElementById('folder-modal').classList.add('hidden')" class="text-gray-300 hover:text-black transition-colors text-xl font-light">&times;</button>
            </div>
            <div id="folder-list" class="p-0 overflow-y-auto flex-1 h-64 bg-white">
                <div class="p-12 text-center text-gray-300 font-light text-sm italic">Escaneando sistema de archivos...</div>
            </div>
        </div>
    </div>

    <header class="h-20 bg-white border-b border-gray-100 flex items-center justify-between px-8 z-10 shrink-0">
        <div class="flex items-center gap-4">
            <div class="w-8 h-8 flex items-center justify-center text-black">
                <i class="fa-solid fa-cube text-lg"></i>
            </div>
            <div class="flex flex-col">
                <h1 class="font-medium text-black text-xs tracking-[0.15em] leading-tight">Extractor Datos<span class="text-gray-400 ml-1">v8.0</span></h1>
                 
            </div>
        </div>
        
        <div class="flex items-center gap-8">
            <div class="flex flex-col items-end gap-1">
                <span class="label-text">Estado API</span>
                <div class="flex items-center gap-2">
                    <span id="status-text" class="text-[10px] font-medium text-gray-300 uppercase tracking-wider">OFFLINE</span>
                    <span id="status-indicator" class="w-1.5 h-1.5 rounded-full bg-gray-200"></span>
                </div>
            </div>

            <div class="h-8 w-px bg-gray-100"></div>

            <div class="flex flex-col items-end gap-1">
                <span class="label-text">Directorio</span>
                <button onclick="app.showFolderModal()" id="target-folder-label" class="text-[10px] font-medium text-black border-b border-gray-200 hover:border-black truncate max-w-[150px] transition-colors pb-0.5">
                    Seleccionar Carpeta
                </button>
            </div>
        </div>
    </header>

    <main class="flex-1 flex overflow-hidden">
        <div class="w-1/2 flex flex-col p-0 border-r border-gray-100 bg-white relative">
            <div class="flex justify-between items-end p-8 pb-4">
                <h2 class="label-text">Fuente Narrativa</h2>
                <button onclick="document.getElementById('source-text').value=''" class="text-[9px] text-gray-300 hover:text-red-400 transition-colors uppercase tracking-widest">Borrar</button>
            </div>
            
            <textarea id="source-text" class="flex-1 w-full px-8 py-4 border-none bg-white focus:ring-0 outline-none resize-none text-sm font-light leading-7 text-gray-600 placeholder-gray-200" 
            placeholder="Escribe o pega tu historia aquí..."></textarea>
            
            <div class="p-8 bg-white">
                <button onclick="app.startProcess()" id="btn-generate" class="btn-primary w-full flex items-center justify-center gap-3 shadow-sm hover:shadow-md transition-all">
                    <span>Iniciar Extracción</span>
                    <i class="fa-solid fa-arrow-right text-[10px]"></i>
                </button>
            </div>
        </div>

        <div class="w-1/2 flex flex-col bg-gray-50/30">
            <div class="px-8 py-8 pb-4 border-b border-gray-100 flex justify-between items-end">
                <h2 class="label-text">Registro del Sistema</h2>
                <span id="timer" class="text-[10px] text-gray-400 font-mono">00:00</span>
            </div>
            
            <div id="process-log" class="flex-1 overflow-y-auto px-8 py-4 space-y-3"></div>
            
            <div class="h-56 bg-white border-t border-gray-100 flex flex-col z-10">
                <div class="px-8 py-4 border-b border-gray-50 flex justify-between items-center bg-white">
                    <h3 class="label-text">Archivos Generados</h3>
                    <i class="fa-regular fa-folder-open text-gray-300 text-xs"></i>
                </div>
                <div id="results-list" class="flex-1 overflow-y-auto p-6 grid grid-cols-1 gap-2 content-start"></div>
            </div>
        </div>
    </main>

    <script>
        // --- BRIDGE CON SILENOS 4 (CONFIG-CORE) ---
        const Sys = window.parent.SystemConfig;
        const FS = window.parent; 

        function updateAuthUI() {
            const indicator = document.getElementById('status-indicator');
            const text = document.getElementById('status-text');

            if (Sys && Sys.authKey) {
                // Online: Punto negro pequeño, texto negro
                indicator.className = "w-1.5 h-1.5 rounded-full bg-black"; 
                text.innerText = "CONECTADO";
                text.className = "text-[10px] font-medium text-black uppercase tracking-wider";
            } else {
                // Offline: Punto gris, texto gris
                indicator.className = "w-1.5 h-1.5 rounded-full bg-gray-200"; 
                text.innerText = "DESCONECTADO";
                text.className = "text-[10px] font-medium text-gray-300 uppercase tracking-wider";
            }
        }

        window.parent.addEventListener('silenos:config-updated', updateAuthUI);

        // --- UTILIDADES ---
        const UTILS = {
            cleanJSON(str) {
                if(!str) return "[]";
                str = str.replace(/```json/g, '').replace(/```/g, '');
                const firstBracket = str.indexOf('[');
                const firstBrace = str.indexOf('{');
                const lastBracket = str.lastIndexOf(']');
                const lastBrace = str.lastIndexOf('}');
                
                if (firstBracket !== -1 && lastBracket !== -1 && (firstBrace === -1 || firstBracket < firstBrace)) {
                    return str.substring(firstBracket, lastBracket + 1);
                }
                if (firstBrace !== -1 && lastBrace !== -1) {
                    return str.substring(firstBrace, lastBrace + 1);
                }
                return str; 
            },
            uuid() { return 'gen-' + Date.now() + '-' + Math.floor(Math.random()*1000); },
            updateProgress(percent) {
                document.getElementById('loading-bar').style.width = percent + '%';
            }
        };

        // --- GENERADOR DE MUNDO V8.0 (SILENOS 4 PORT) ---
        class NarrativeGenerator {
            constructor() {
                this.targetHandle = null; 
                this.targetPathName = null;
                this.isProcessing = false; 
                this.startTime = 0; 
                this.timerInterval = null;
                this.entityNames = [];
            }

            async init() {
                updateAuthUI();
                await this.refreshFolderList();
            }

            // --- SCANNER DE DIRECTORIOS (Visualización Minimalista) ---
            async refreshFolderList() {
                const list = document.getElementById('folder-list'); 
                list.innerHTML = '';

                if (!FS.rootHandle) {
                    list.innerHTML = '<div class="p-8 text-center text-xs text-red-400 font-light">Root Handle not found.</div>';
                    return;
                }

                this.addFolderOption(list, FS.rootHandle, 'ROOT', true);
                await this.scanDirRecursive(FS.rootHandle, list, 'ROOT');
            }

            async scanDirRecursive(dirHandle, listElement, pathString, depth = 0) {
                if (depth > 3) return; 

                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'directory') {
                        const currentPath = `${pathString} / ${entry.name}`;
                        this.addFolderOption(listElement, entry, currentPath);
                        await this.scanDirRecursive(entry, listElement, currentPath, depth + 1);
                    }
                }
            }

            addFolderOption(container, handle, displayName, isRoot = false) {
                const el = document.createElement('div');
                // Lista limpia: solo texto gris oscuro, hover gris claro fondo
                el.className = "px-6 py-3 cursor-pointer border-b border-gray-50 flex items-center gap-4 text-xs font-light text-gray-600 hover:bg-gray-50 transition-colors";
                
                // Iconos muy sutiles
                const iconClass = isRoot ? 'fa-database' : 'fa-folder';
                const colorClass = isRoot ? 'text-black' : 'text-gray-300';
                
                // Si es subcarpeta, indentamos visualmente un poco con el icono
                el.innerHTML = `
                    <i class="fa-solid ${iconClass} ${colorClass} text-[10px]"></i>
                    <span class="truncate w-full tracking-wide">${displayName}</span>
                `;
                
                el.onclick = () => {
                    this.targetHandle = handle;
                    this.targetPathName = displayName;
                    document.getElementById('target-folder-label').innerText = displayName;
                    document.getElementById('folder-modal').classList.add('hidden');
                };
                container.appendChild(el);
            }

            showFolderModal() { 
                this.refreshFolderList(); 
                document.getElementById('folder-modal').classList.remove('hidden'); 
            }
            
            // --- API CALLER ---
            async aiCall(prompt, systemOverride = null) {
                if (!Sys || !Sys.authKey) {
                    this.log("Falta clave de autorización", "error");
                    throw new Error("Auth Required");
                }
                const systemPrompt = systemOverride || "Eres un experto en Worldbuilding y análisis de datos. Responde siempre estrictamente JSON.";
                
                try {
                    const response = await fetch('https://gen.pollinations.ai/v1/chat/completions', {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${Sys.authKey}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            model: 'openai-large', 
                            messages: [{ role: 'system', content: systemPrompt }, { role: 'user', content: prompt }] 
                        })
                    });
                    if (!response.ok) throw new Error(`API Error: ${response.status}`);
                    const data = await response.json();
                    return data.choices[0].message.content;
                } catch (error) {
                    console.error("AI Error:", error);
                    return "";
                }
            }

            // MODIFICADO VISUALMENTE: Logs "Swedish Style"
            log(msg, type = 'info') {
                const c = document.getElementById('process-log');
                const el = document.createElement('div');
                
                // Base: Texto limpio, sin bordes, tipografía mono muy fina
                let base = 'log-enter flex gap-3 items-start text-[10px] font-mono leading-relaxed text-gray-500';
                let iconHTML = `<span class="mt-1 w-1 h-1 rounded-full bg-gray-300 shrink-0"></span>`; // Punto gris por defecto
                
                if(type==='success') { 
                    base = 'log-enter flex gap-3 items-start text-[10px] font-mono leading-relaxed text-black'; // Éxito es negro
                    iconHTML = `<i class="fa-solid fa-check mt-0.5 text-black text-[8px]"></i>`;
                }
                if(type==='error') { 
                    base = 'log-enter flex gap-3 items-start text-[10px] font-mono leading-relaxed text-red-500'; 
                    iconHTML = `<i class="fa-solid fa-xmark mt-0.5 text-red-500 text-[8px]"></i>`;
                } 
                if(type==='warn') { 
                    iconHTML = `<span class="mt-1 w-1 h-1 rounded-full bg-orange-300 shrink-0"></span>`;
                }
                if(type==='detail') { 
                    base = 'log-enter flex gap-3 items-start text-[10px] font-mono leading-relaxed text-gray-400 pl-4'; // Indentado y más claro
                    iconHTML = `<span class="mt-1 w-px h-2 bg-gray-200 shrink-0"></span>`; // Línea vertical sutil
                }
                
                el.className = base;
                el.innerHTML = `${iconHTML} <span>${msg}</span>`;
                c.prepend(el);
            }

            // MODIFICADO VISUALMENTE: Resultados limpios
            addResult(filename, type) {
                const list = document.getElementById('results-list');
                const el = document.createElement('div');
                
                let iconClass = 'fa-regular fa-file-code';
                if(type==='time') iconClass = 'fa-regular fa-clock';
                
                // Estilo tarjeta minimalista muy suave o simplemente fila
                el.className = "group flex items-center justify-between p-3 border border-gray-100 hover:border-gray-300 transition-colors bg-white";
                
                el.innerHTML = `
                    <div class="flex items-center gap-3">
                        <i class="${iconClass} text-gray-300 group-hover:text-black transition-colors text-xs"></i>
                        <span class="text-xs font-mono text-gray-600 group-hover:text-black transition-colors">${filename}</span>
                    </div>
                    <span class="text-[8px] uppercase tracking-widest text-gray-300">Guardado</span>
                `;
                list.prepend(el);
            }

            // --- LÓGICA PRINCIPAL (INTACTA) ---

            async startProcess() {
                const text = document.getElementById('source-text').value.trim();
                
                if (!this.targetHandle) {
                    this.log("Selecciona una carpeta de destino", "error");
                    if(FS && FS.showToast) FS.showToast("Falta Carpeta");
                    return;
                }
                if (!text) {
                    this.log("El campo de texto está vacío", "error");
                    if(FS && FS.showToast) FS.showToast("Falta Texto");
                    return;
                }
                if (!Sys || !Sys.authKey) {
                    this.log("Sistema no autenticado", "error");
                    if(FS && FS.showToast) FS.showToast("Falta Auth");
                    return;
                }

                this.isProcessing = true;
                this.entityNames = [];
                document.getElementById('btn-generate').disabled = true;
                document.getElementById('btn-generate').innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i><span>Procesando...</span>';
                document.getElementById('process-log').innerHTML = '';
                UTILS.updateProgress(5);
                this.startTimer();

                try {
                    this.log("Iniciando secuencia de extracción", "info");

                    // 1. SINOPSIS
                    this.log("Analizando estructura narrativa...", "info");
                    const storyOutline = await this.aiCall_GetStoryOutline(text);
                    UTILS.updateProgress(10);

                    // 2. DETECCIÓN DE ENTIDADES
                    this.log("Identificando entidades...", "info");
                    let allEntities = await this.deepScanWorldEntities(text);
                    
                    if (allEntities.length === 0) {
                        this.log("No se detectaron entidades específicas.", "warn");
                        allEntities = ["Misterio"];
                    } else {
                        this.log(`Elementos identificados: ${allEntities.length}`, "success");
                    }
                    this.entityNames = allEntities;
                    UTILS.updateProgress(20);

                    // 3. GENERACIÓN DE DATOS (BATCH)
                    this.log(`Comenzando generación de fichas`, "info");
                    
                    const batchSize = 5; 
                    for (let i = 0; i < allEntities.length; i += batchSize) {
                        const batch = allEntities.slice(i, i + batchSize);
                        this.log(`Procesando lote ${(i/batchSize)+1} (${batch.length} items)`, "detail");
                        
                        const promises = batch.map(name => this.processEntityItem(name, text, storyOutline));
                        await Promise.all(promises);
                        
                        const completedCount = Math.min(i + batchSize, allEntities.length);
                        const progress = 20 + Math.floor((completedCount/allEntities.length) * 30);
                        UTILS.updateProgress(progress);
                        
                        if (window.parent.btnRefresh) window.parent.btnRefresh.click();
                    }
                    this.log("Generación de entidades completada.", "success");

                    // 4. CRONOLOGÍA
                    await this.workflow_Timeline_Simple(text);

                    this.log("Proceso finalizado con éxito.", "success");
                    UTILS.updateProgress(100);

                    if (window.parent.btnRefresh) window.parent.btnRefresh.click();

                } catch (error) {
                    console.error(error);
                    this.log(`Error crítico: ${error.message}`, "error");
                } finally {
                    this.isProcessing = false;
                    document.getElementById('btn-generate').disabled = false;
                    document.getElementById('btn-generate').innerHTML = '<span>Iniciar Extracción</span><i class="fa-solid fa-arrow-right text-[10px]"></i>';
                    this.stopTimer();
                }
            }
            
            async processEntityItem(entityName, text, storyOutline) {
                const specificContext = this.extractEntityContext(entityName, text);
                try {
                    const entityData = await this.aiCall_GenerateEntityData(entityName, specificContext, storyOutline);
                    if(entityData) {
                        await this.saveEntityFile(entityName, entityData);
                    }
                } catch(e) { 
                    console.error(`Error procesando ${entityName}`, e);
                    this.log(`Fallo al generar: ${entityName}`, "warn");
                }
            }

            async workflow_Timeline_Simple(text) {
                this.log("Construyendo línea temporal...", "info");
                
                const mid = Math.floor(text.length / 2);
                const sampleText = text.substring(0, 15000) + "\n...\n" + text.substring(mid, mid+15000) + "\n...\n" + text.substring(text.length - 15000);

                const json = await this.aiCall(`
                    Eres un cronista. Analiza la historia y extrae una lista ordenada de EVENTOS CLAVE.
                    TEXTO: "${sampleText}..."
                    FORMATO JSON: { "events": [ { "time": number (año/índice), "description": "Título breve" } ] }
                    Usa decimales para eventos cercanos (2023.1, 2023.2).
                `);

                let baseEvents = [];
                try { baseEvents = JSON.parse(UTILS.cleanJSON(json)).events || []; } catch(e) { baseEvents = [{time: 1, description: "Inicio"}]; }

                this.log(`Detallando ${baseEvents.length} eventos clave...`, "info");
                
                const enrichedEvents = [];
                
                for (let i = 0; i < baseEvents.length; i++) {
                    const evt = baseEvents[i];
                    const progress = 50 + Math.floor(((i+1)/baseEvents.length) * 50);
                    UTILS.updateProgress(progress);
                    
                    this.log(`Evento ${i+1}: ${evt.description.substring(0, 40)}...`, "detail");

                    const detail = await this.aiCall_EnrichEvent(evt, text, this.entityNames);
                    if (detail) {
                        enrichedEvents.push(detail);
                        
                        await this.saveTimelineFile({
                            name: "Línea Temporal de la Historia",
                            status: "building",
                            lastUpdate: new Date().toISOString(),
                            eventsLoaded: enrichedEvents.length,
                            totalExpected: baseEvents.length,
                            events: enrichedEvents
                        });
                    }
                    
                    await new Promise(r => setTimeout(r, 500));
                }

                await this.saveTimelineFile({
                    name: "Línea Temporal Completa",
                    status: "complete",
                    lastUpdate: new Date().toISOString(),
                    events: enrichedEvents
                });
            }

            async aiCall_EnrichEvent(baseEvent, fullText, knownEntities) {
                const safeContext = fullText.substring(0, 80000); 

                const prompt = `
                    Analiza el evento: "${baseEvent.description}" (Tiempo: ${baseEvent.time}).
                    CONTEXTO: "${safeContext}..."
                    
                    ENTIDADES CONOCIDAS: ${JSON.stringify(knownEntities)}

                    TAREA:
                    Desglosa el evento en una secuencia de entre 2 y 7 MOMENTOS (pasos).
                    Si alguna entidad participa, USA SU NOMBRE EXACTO.
                    
                    JSON REQUERIDO:
                    {
                        "moments": ["Texto del momento 1...", "Texto del momento 2..."]
                    }
                `;

                const res = await this.aiCall(prompt);
                
                let data = { moments: [] };
                try {
                    data = JSON.parse(UTILS.cleanJSON(res));
                } catch(e) { 
                    data.moments = [baseEvent.description];
                }

                const momentObjects = (data.moments || []).map(txt => ({ 
                    id: Date.now() + Math.random(), 
                    text: txt 
                }));
                
                if (momentObjects.length === 0) momentObjects.push({ id: Date.now(), text: baseEvent.description });

                return {
                    id: UTILS.uuid(),
                    time: baseEvent.time,
                    description: baseEvent.description,
                    moments: momentObjects, 
                    image64: null 
                };
            }

            async deepScanWorldEntities(fullText) {
                const chunkSize = 15000;
                const chunks = [];
                for (let i = 0; i < fullText.length; i += chunkSize) {
                    chunks.push(fullText.substring(i, i + chunkSize));
                }
                let globalNames = new Set();
                
                const promptBase = "Extrae nombres propios de ENTIDADES (Personajes, Lugares, Objetos, Facciones). Devuelve JSON Array of Strings.";

                for (let i = 0; i < chunks.length; i++) {
                    this.log(`Escaneando segmento ${i+1}/${chunks.length}`, "detail");
                    const res = await this.aiCall(`${promptBase} FRAGMENTO: "${chunks[i]}..."`);
                    try {
                        const names = JSON.parse(UTILS.cleanJSON(res));
                        if (Array.isArray(names)) names.forEach(n => {
                            let cleanName = n.trim().replace(/[^\w\sÁÉÍÓÚáéíóúñÑ\-']/g, "");
                            if (cleanName.length > 2 && cleanName.length < 30) globalNames.add(cleanName);
                        });
                    } catch (e) {}
                    await new Promise(r => setTimeout(r, 500));
                }
                const rawList = Array.from(globalNames);
                if (rawList.length > 1) {
                    const consolidated = await this.aiCall(`Consolida lista (elimina duplicados). JSON Array. LISTA: ${JSON.stringify(rawList)}`);
                    try { return JSON.parse(UTILS.cleanJSON(consolidated)); } catch (e) { return rawList; }
                }
                return rawList;
            }

            extractEntityContext(name, fullText) {
                const regex = new RegExp(name.split(" ")[0].replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "gi");
                let matches; let context = ""; let count = 0; const limit = 5000;
                while ((matches = regex.exec(fullText)) !== null && context.length < limit && count < 5) {
                    const start = Math.max(0, matches.index - 200);
                    const end = Math.min(fullText.length, matches.index + 500);
                    context += `...: ` + fullText.substring(start, end) + "\n";
                    count++;
                }
                if (context.length < 10) return fullText.substring(0, 3000); 
                return context;
            }

            async aiCall_GetStoryOutline(text) {
                return await this.aiCall(`Resume premisa, conflicto y tono en 1 párrafo: "${text.substring(0, 3000)}..."`);
            }

            async aiCall_GenerateEntityData(name, specificContext, outline) {
                const targetStructure = {
                    name: name, 
                    desc: "Descripción narrativa detallada.",
                    visualDesc: "Prompt visual detallado.",
                    type: "Personaje|Lugar|Objeto",
                    tags: "tag1, tag2" 
                };

                const jsonStr = await this.aiCall(`
                    Genera ficha Worldbuilding para "${name}". 
                    SINOPSIS: ${outline}. 
                    CONTEXTO: "${specificContext}".
                    JSON: ${JSON.stringify(targetStructure)}
                `);

                try {
                    const parsed = JSON.parse(UTILS.cleanJSON(jsonStr));
                    return { ...targetStructure, ...parsed }; 
                } catch (e) { return targetStructure; }
            }

            async saveEntityFile(name, data) {
                if (!this.targetHandle) return;
                const cleanName = name.trim().replace(/[^a-z0-9]/gi, '_').toLowerCase();
                const filename = `${cleanName}.json`;
                const content = JSON.stringify(data, null, 2);

                try {
                    const fileHandle = await this.targetHandle.getFileHandle(filename, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    this.addResult(filename, 'entity');
                } catch(e) {
                    console.error("Save Error:", e);
                    this.log(`Error de escritura: ${filename}`, 'error');
                }
            }

            async saveTimelineFile(data) {
                if (!this.targetHandle) return;
                const filename = `TIMELINE_DATA.json`;
                const content = JSON.stringify(data, null, 2);

                try {
                    const fileHandle = await this.targetHandle.getFileHandle(filename, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    const existingLog = Array.from(document.querySelectorAll('#results-list span')).find(s => s.textContent === filename);
                    if(!existingLog) this.addResult(filename, 'time');
                } catch(e) {
                    console.error("Save Error Timeline:", e);
                }
            }

            startTimer() {
                this.startTime = Date.now();
                this.timerInterval = setInterval(() => {
                    const delta = Math.floor((Date.now() - this.startTime) / 1000);
                    const m = Math.floor(delta / 60).toString().padStart(2, '0');
                    const s = (delta % 60).toString().padStart(2, '0');
                    document.getElementById('timer').innerText = `${m}:${s}`;
                }, 1000);
            }
            stopTimer() { clearInterval(this.timerInterval); }
        }

        const app = new NarrativeGenerator();
        window.onload = () => app.init();
    </script>
</body>
</html>