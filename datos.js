// ===================================
// GESTI√ìN DE DATOS Y ETIQUETAS
// ===================================

const opcionesEtiqueta = [
    { emoji: '‚¶æ', valor: 'indeterminado', titulo: 'Indeterminado' },
    { emoji: 'üßç', valor: 'personaje', titulo: 'Personaje' },
    { emoji: 'üó∫Ô∏è', valor: 'ubicacion', titulo: 'Ubicaci√≥n' },
    { emoji: 'üóìÔ∏è', valor: 'evento', titulo: 'Evento' },
    { emoji: 'üõ†Ô∏è', valor: 'objeto', titulo: 'Objeto' },
    { emoji: 'üí≠', valor: 'concepto', titulo: 'Concepto' },
    { emoji: 'üìù', valor: 'nota', titulo: 'Nota' },
];

// Funci√≥n de ayuda para convertir un archivo a formato Base64
function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = error => reject(error);
    });
}

/**
 * Muestra un men√∫ emergente para seleccionar una etiqueta.
 * @param {HTMLElement} botonEtiqueta - El bot√≥n que activ√≥ el men√∫.
 */
function mostrarMenuEtiquetas(botonEtiqueta) {
    // Elimina cualquier men√∫ anterior para evitar duplicados
    const menuExistente = document.querySelector('.menu-etiquetas');
    if (menuExistente) menuExistente.remove();

    const menu = document.createElement('div');
    menu.className = 'menu-etiquetas';

    opcionesEtiqueta.forEach(opcion => {
        const itemMenu = document.createElement('div');
        itemMenu.className = 'item-menu-etiqueta';
        itemMenu.textContent = `${opcion.emoji} ${opcion.titulo}`;
        
        itemMenu.onclick = (e) => {
            e.stopPropagation(); // Evita que el clic se propague y cierre el overlay
            botonEtiqueta.innerHTML = opcion.emoji;
            botonEtiqueta.title = `Etiqueta: ${opcion.titulo}`;
            botonEtiqueta.dataset.etiqueta = opcion.valor;
            menu.remove();
        };
        menu.appendChild(itemMenu);
    });

    document.body.appendChild(menu);
    const rect = botonEtiqueta.getBoundingClientRect();
    menu.style.top = `${rect.bottom + window.scrollY + 5}px`;
    menu.style.left = `${rect.left + window.scrollX}px`;

    // Cierra el men√∫ si se hace clic en cualquier otro lugar
    const cerrarMenuHandler = (e) => {
        if (!menu.contains(e.target)) {
            menu.remove();
            document.removeEventListener('click', cerrarMenuHandler, true);
        }
    };
    setTimeout(() => document.addEventListener('click', cerrarMenuHandler, true), 100);
}

/**
 * Crea y a√±ade un nuevo elemento de "Dato" al DOM.
 * @param {object} personajeData - El objeto con los datos del personaje/dato.
 */
function agregarPersonajeDesdeDatos(personajeData = {}) {
    const { 
        nombre = '', 
        descripcion = '', 
        imagen = '', 
        etiqueta: etiquetaValor = 'indeterminado' 
    } = personajeData;

    const lista = document.getElementById('listapersonajes');
    if (!lista) return;

    // --- Contenedor Principal de la Tarjeta ---
    const contenedor = document.createElement('div');
    contenedor.className = 'personaje';

    // --- Parte Visual (El cuadrado clicable) ---
    const visual = document.createElement('div');
    visual.className = 'personaje-visual';
    
    const img = document.createElement('img');
    const descripcionPreview = document.createElement('div');
    descripcionPreview.className = 'personaje-descripcion-preview';
    
    // Funci√≥n para actualizar la visibilidad y contenido
    const actualizarVisual = (nuevaImagenSrc, nuevaDescripcion) => {
        img.src = nuevaImagenSrc || '';
        descripcionPreview.textContent = nuevaDescripcion;
        
        if (img.src && !img.src.endsWith('/')) { // Si hay una URL de imagen v√°lida
             img.classList.remove('hidden');
        } else {
             img.classList.add('hidden');
        }
    };
    
    img.onerror = () => { img.classList.add('hidden'); };
    img.onload = () => {
        if (img.src && !img.src.endsWith('/')) {
            img.classList.remove('hidden');
        }
    }
    
    visual.appendChild(img);
    visual.appendChild(descripcionPreview);
    contenedor.appendChild(visual);

    // --- Nombre (posicionado debajo del cuadrado) ---
    const cajaNombre = document.createElement('input');
    cajaNombre.type = 'text';
    cajaNombre.className = 'nombreh';
    cajaNombre.value = nombre;
    cajaNombre.placeholder = 'Nombre';
    contenedor.appendChild(cajaNombre);

    // --- Overlay de Edici√≥n (inicialmente oculto) ---
    const overlay = document.createElement('div');
    overlay.className = 'personaje-edit-overlay';
    const editControls = document.createElement('div');
    editControls.className = 'edit-controls';
    const cajaTexto = document.createElement('textarea');
    cajaTexto.value = descripcion;
    cajaTexto.placeholder = 'Descripci√≥n...';
    // Actualiza la vista previa en tiempo real mientras se escribe
    cajaTexto.addEventListener('input', () => {
        actualizarVisual(img.src, cajaTexto.value);
    });
    editControls.appendChild(cajaTexto);

    const buttonsWrapper = document.createElement('div');
    buttonsWrapper.className = 'edit-buttons-wrapper';

    // Bot√≥n para cambiar imagen
    const botonCargar = document.createElement('button');
    botonCargar.className = 'edit-btn change-image-btn';
    botonCargar.innerHTML = 'üì∑';
    botonCargar.title = 'Cambiar Imagen';
    botonCargar.onclick = () => {
        const inputFile = document.createElement('input');
        inputFile.type = 'file';
        inputFile.accept = 'image/*, video/mp4, video/webm, image/gif';
        inputFile.onchange = async (event) => {
            if (event.target.files && event.target.files[0]) {
                const nuevaImagen = await fileToBase64(event.target.files[0]);
                actualizarVisual(nuevaImagen, cajaTexto.value);
            }
        };
        inputFile.click();
    };
    buttonsWrapper.appendChild(botonCargar);

    // Bot√≥n para elegir etiqueta
    const etiquetaBtn = document.createElement('button');
    etiquetaBtn.className = 'edit-btn change-tag-btn';
    const opcionGuardada = opcionesEtiqueta.find(op => op.valor === etiquetaValor) || opcionesEtiqueta[0];
    etiquetaBtn.innerHTML = opcionGuardada.emoji;
    etiquetaBtn.title = `Etiqueta: ${opcionGuardada.titulo}`;
    etiquetaBtn.dataset.etiqueta = opcionGuardada.valor;
    etiquetaBtn.onclick = () => mostrarMenuEtiquetas(etiquetaBtn);
    buttonsWrapper.appendChild(etiquetaBtn);
    
    // Bot√≥n para eliminar dato
    const botonEliminar = document.createElement('button');
    botonEliminar.className = 'edit-btn delete-btn';
    botonEliminar.innerHTML = 'üóëÔ∏è';
    botonEliminar.title = 'Eliminar Dato';
    botonEliminar.onclick = () => {
        // Usamos un modal de confirmaci√≥n personalizado en lugar de `confirm()` si es posible.
        // Por ahora, `confirm` es una soluci√≥n simple.
        if (confirm(`¬øEst√°s seguro de que quieres eliminar "${cajaNombre.value || 'este dato'}"?`)) {
            contenedor.remove();
        }
    };
    buttonsWrapper.appendChild(botonEliminar);

    editControls.appendChild(buttonsWrapper);
    overlay.appendChild(editControls);
    contenedor.appendChild(overlay);

    lista.appendChild(contenedor);
    
    // Llamada inicial para establecer el estado correcto al crear la tarjeta
    actualizarVisual(imagen, descripcion);
}


function agregarPersonaje() {
    agregarPersonajeDesdeDatos();
}


function inicializarInteraccionPersonajes() {
    const listaPersonajesEl = document.getElementById('listapersonajes');
    if (!listaPersonajesEl) return;

    listaPersonajesEl.addEventListener('click', (e) => {
        const visualClicked = e.target.closest('.personaje-visual');
        if (visualClicked) {
            const personajeActual = visualClicked.closest('.personaje');
            if (!personajeActual) return;
            const personajeActivo = document.querySelector('.personaje.editing');
            if (personajeActivo && personajeActivo !== personajeActual) {
                personajeActivo.classList.remove('editing');
            }
            personajeActual.classList.toggle('editing');
        }
    });

    document.addEventListener('click', (e) => {
        const personajeActivo = document.querySelector('.personaje.editing');
        if (personajeActivo && !e.target.closest('.personaje.editing')) {
             personajeActivo.classList.remove('editing');
        }
    }, true);
}

document.addEventListener('DOMContentLoaded', inicializarInteraccionPersonajes);


// =========================================================================
// OTRAS FUNCIONES (IA, etc.) - Sin modificar
// =========================================================================

async function procesarEntradaConIA() {
    const textoUsuario = document.getElementById('ia-datos-area').value.trim();
    if (!textoUsuario) {
        alert("Por favor, introduce alg√∫n texto para analizar.");
        return;
    }
    cerrarModalAIDatos();
    const chatDiv = window.chatDiv || document.getElementById('chat');
    chatDiv.innerHTML += `<p><strong>Solicitud enviada:</strong> Analizando entrada...</p>`;
    chatDiv.scrollTop = chatDiv.scrollHeight;
    const pareceJson = textoUsuario.startsWith('[') || textoUsuario.startsWith('{');
    if (pareceJson) {
        chatDiv.innerHTML += `<p><strong>Info:</strong> Se ha detectado una estructura tipo JSON. Se intentar√° formatear.</p>`;
        chatDiv.scrollTop = chatDiv.scrollHeight;
        const promptCorreccion = `
        Rol: Eres un asistente experto en formateo de datos para una aplicaci√≥n de escritura llamada Silenos.
        Tarea: Convierte la siguiente cadena de texto en un array JSON v√°lido que siga la estructura de Silenos.
        Estructura de Salida Requerida por Objeto:
        {
          "nombre": "string",
          "descripcion": "string",
          "etiqueta": "string",
          "imagen": ""
        }
        Instrucciones Clave:
        1.  **Sintetiza la Descripci√≥n:** Combina toda la informaci√≥n relevante del objeto de entrada (como 'casa', 'vestimenta', 'estilo', etc.) en un √∫nico y coherente p√°rrafo de texto para el campo "descripcion".
        2.  **Asigna una Etiqueta:** Basado en el contenido, asigna la etiqueta m√°s apropiada (ej: 'personaje', 'estilo', 'ubicacion').
        3.  **No Inventes Nada:** No a√±adas informaci√≥n que no est√© en el texto de entrada.
        4.  **No Identifiques la Obra:** No menciones de qu√© libro o pel√≠cula son los datos. Tu √∫nica tarea es la conversi√≥n estructural.
        Texto a convertir:
        ---
        ${textoUsuario}
        ---
        Responde √öNICAMENTE con el array JSON corregido y formateado. No a√±adas explicaciones.`;
        try {
            const respuestaCorregida = await llamarIAConFeedback(promptCorreccion, "formateando JSON a la estructura de Silenos");
            if (Array.isArray(respuestaCorregida) && respuestaCorregida.length > 0 && respuestaCorregida.every(d => d.nombre && d.descripcion && d.etiqueta)) {
                let importados = 0;
                respuestaCorregida.forEach(dato => {
                    agregarPersonajeDesdeDatos(dato);
                    importados++;
                });
                alert(`La IA formate√≥ la entrada y se importaron ${importados} datos.`);
                document.getElementById('ia-datos-area').value = '';
            } else {
                throw new Error("La IA no pudo formatear el JSON a la estructura esperada o devolvi√≥ un array vac√≠o.");
            }
        } catch (error) {
            alert("Error al intentar formatear el JSON con la IA. " + error.message);
            console.error("Error formateando JSON:", error);
        }
        return;
    }
    chatDiv.innerHTML += `<p><strong>Info:</strong> Se detect√≥ texto plano. Se asumir√° que es una obra de ficci√≥n y se proceder√° a su an√°lisis detallado.</p>`;
    try {
        const promptCategorias = `
        Analiza el nombre de la siguiente obra de ficci√≥n: "${textoUsuario}".
        Tu tarea es identificar y listar las categor√≠as de datos m√°s importantes y relevantes de esta obra (por ejemplo: Personajes Principales, Personajes Secundarios, Lugares Clave, Objetos M√°gicos, Facciones, Eventos Hist√≥ricos, Criaturas, etc.).
        Responde √öNICAMENTE con un objeto JSON v√°lido. La estructura debe ser:
        {
          "categorias_identificadas": ["Categor√≠a 1", "Categor√≠a 2", "Categor√≠a 3"]
        }`;
        const respuestaCategorias = await llamarIAConFeedback(promptCategorias, `Paso 1: Identificando categor√≠as para "${textoUsuario}"`);
        const categorias = respuestaCategorias.categorias_identificadas;
        if (!categorias || !Array.isArray(categorias) || categorias.length === 0) {
            throw new Error("La IA no pudo identificar categor√≠as relevantes para la obra proporcionada.");
        }
        chatDiv.innerHTML += `<p><strong>Categor√≠as encontradas:</strong> ${categorias.join(', ')}. Iniciando extracci√≥n detallada...</p>`;
        chatDiv.scrollTop = chatDiv.scrollHeight;
        let totalDatosImportados = 0;
        for (const categoria of categorias) {
            let exitoCategoria = false;
            let reintentos = 0;
            const maxReintentos = 2;

            while (!exitoCategoria && reintentos < maxReintentos) {
                try {
                    if (reintentos > 0) {
                        chatDiv.innerHTML += `<p><strong>Reintentando...</strong> (intento ${reintentos + 1}) para la categor√≠a: <strong>${categoria}</strong></p>`;
                    } else {
                        chatDiv.innerHTML += `<p><strong>Extrayendo...</strong> solicitando datos para la categor√≠a: <strong>${categoria}</strong></p>`;
                    }
                    chatDiv.scrollTop = chatDiv.scrollHeight;
                    
                    const etiquetaSugerida = categoria.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
                    const promptDetalles = `
                    Para la obra "${textoUsuario}", genera una lista de elementos que pertenecen a la categor√≠a "${categoria}".
                    Para cada elemento, proporciona una descripci√≥n EXTREMADAMENTE DETALLADA.
                    Responde √öNICAMENTE con un objeto JSON v√°lido en formato de array. Cada objeto debe tener: {"nombre": "...", "descripcion": "...", "etiqueta": "${etiquetaSugerida}", "imagen": ""}`;

                    const respuestaDetalles = await llamarIAConFeedback(promptDetalles, `Paso 2: Extrayendo detalles de "${categoria}"`);
                    
                    if (Array.isArray(respuestaDetalles) && respuestaDetalles.length > 0) {
                        let importadosCategoria = 0;
                        respuestaDetalles.forEach(dato => {
                            if (dato.nombre && dato.descripcion && dato.etiqueta) {
                                agregarPersonajeDesdeDatos(dato);
                                importadosCategoria++;
                            }
                        });
                        totalDatosImportados += importadosCategoria;
                        chatDiv.innerHTML += `<p><strong>√âxito:</strong> Se agregaron ${importadosCategoria} datos de la categor√≠a "${categoria}".</p>`;
                        exitoCategoria = true;
                    } else {
                        throw new Error(`La IA no devolvi√≥ datos para la categor√≠a "${categoria}".`);
                    }

                } catch (errorCategoria) {
                    reintentos++;
                    chatDiv.innerHTML += `<p><strong>Error en categor√≠a "${categoria}"</strong> (intento ${reintentos}): ${errorCategoria.message}</p>`;
                    if (reintentos >= maxReintentos) {
                        chatDiv.innerHTML += `<p><strong>Fallo definitivo:</strong> No se pudieron extraer datos para "${categoria}".</p>`;
                    }
                }
                chatDiv.scrollTop = chatDiv.scrollHeight;
            }
        }
        
        if (totalDatosImportados > 0) {
            alert(`¬°Proceso completado! Se importaron un total de ${totalDatosImportados} datos detallados.`);
            document.getElementById('ia-datos-area').value = '';
        } else {
            alert("El proceso finaliz√≥, pero no se pudo importar ning√∫n dato. Revisa el panel de chat para m√°s informaci√≥n.");
        }

    } catch (error) {
        alert("Ocurri√≥ un error general al procesar la solicitud. Revisa el panel de chat y la consola para m√°s detalles.\n\nMensaje: " + error.message);
        console.error("Error en procesarEntradaConIA:", error);
    } finally {
        chatDiv.scrollTop = chatDiv.scrollHeight;
    }
}
/**
 * Adds a delete button to each character element.
 * This function assumes character elements have a class 'personaje' 
 * and that you have a function to handle the actual data deletion.
 */
function agregarBotonEliminarAPersonajes() {
    // Select all character containers. We'll assume they have the class '.personaje' based on your CSS.
    const personajes = document.querySelectorAll('.personaje');

    personajes.forEach(personajeDiv => {
        // Prevent adding a button if one already exists
        if (personajeDiv.querySelector('.eliminar-personaje-btn')) {
            return;
        }

        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Eliminar';
        deleteButton.className = 'eliminar-personaje-btn pro'; // Add classes for styling

        // Add the click event to handle the deletion
        deleteButton.onclick = function(event) {
            // Stop the click from propagating to parent elements
            event.stopPropagation();

            // Confirm before deleting
            if (confirm('¬øEst√°s seguro de que quieres eliminar este dato?')) {
                // Here, you would typically remove the character from your data array first.
                // For example:
                // const characterId = personajeDiv.dataset.id; // Assuming you set a data-id attribute
                // eliminarDatoPorId(characterId); // A function you would create in datos.js

                // Then, remove the element from the DOM
                personajeDiv.remove();
            }
        };

        // Append the button to the character's div
        personajeDiv.appendChild(deleteButton);
    });
}


document.addEventListener('DOMContentLoaded', () => {
    const selectorBtn = document.getElementById('selector-guion-btn-local');
    const popup = document.getElementById('lista-guiones-popup-local');

    // Si el bot√≥n existe en la p√°gina actual, le a√±adimos la funcionalidad.
    if (selectorBtn && popup) {
        
        // Funci√≥n para llenar el popup con la lista de cap√≠tulos (guiones).
        function popularListaGuiones() {
            popup.innerHTML = ''; // Limpia la lista anterior para no duplicar.

            // Usa el array 'guionLiterarioData' que ya tienes en tu c√≥digo.
            guionLiterarioData.forEach((capitulo, index) => {
                const item = document.createElement('button');
                item.className = 'guion-popup-item-local'; // Estilo definido en styles.css.
                item.textContent = capitulo.titulo;
                
                // Al hacer clic en un guion de la lista, lo muestra y cierra el popup.
                item.onclick = () => {
                    mostrarCapituloSeleccionado(index); // Funci√≥n que ya usas para mostrar cap√≠tulos.
                    popup.style.display = 'none';
                };
                popup.appendChild(item);
            });
        }

        // 1. Evento principal: Abrir/cerrar el popup al hacer clic en el bot√≥n '‚ò∞'.
        selectorBtn.addEventListener('click', (event) => {
            event.stopPropagation(); // Evita que el clic se propague y cierre el men√∫ inmediatamente.
            
            const isVisible = popup.style.display === 'block';

            if (!isVisible) {
                popularListaGuiones(); // Rellena la lista cada vez que se abre.
                popup.style.display = 'block';
            } else {
                popup.style.display = 'none';
            }
        });

        // 2. Evento secundario: Cerrar el popup si se hace clic en cualquier otro lugar de la p√°gina.
        document.addEventListener('click', () => {
            if (popup.style.display === 'block') {
                popup.style.display = 'none';
            }
        });

        // 3. Evitar que el popup se cierre al hacer clic dentro de √©l.
        popup.addEventListener('click', (event) => {
            event.stopPropagation();
        });
    }
});