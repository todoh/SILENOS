// ===================================
// GESTI√ìN DE ESCENAS Y FRAMES
// ===================================

function nuevaEscena() {
    // A√ëADIDO: Comprobar si hay un libro activo antes de crear un cap√≠tulo
    if (!libroActivoId) {
        alert("Por favor, selecciona o crea un libro usando el bot√≥n 'üìö Seleccionar Libro' antes de a√±adir un cap√≠tulo.");
        return;
    }

    ultimoId++;
    let id = String(ultimoId).padStart(3, '0');
    while (escenas[id]) {
        ultimoId++;
        id = String(ultimoId).padStart(3, '0');
    }
    
    // MODIFICADO: A√±adir la propiedad libroId al crear la escena/cap√≠tulo
    escenas[id] = {
        tipo: "generica",
        texto: "", // El usuario le pondr√° nombre
        imagen: "",
        opciones: [],
        botones: [],
        frames: [],
        generadoPorIA: false,
        libroId: libroActivoId // <-- L√çNEA A√ëADIDA
    };

    if (typeof(Storage) !== "undefined") {
        localStorage.setItem("escenas", JSON.stringify(escenas));
    } else {
        console.error("localStorage no est√° disponible en este navegador.");
    }
    actualizarLista();
}

function agregarFrame(escenaId, indiceInsercion) {
    if (!escenas[escenaId]) return;
    const nuevoFrame = { texto: "", imagen: "" };
    if (indiceInsercion !== undefined) {
        escenas[escenaId].frames.splice(indiceInsercion + 1, 0, nuevoFrame);
    } else {
        escenas[escenaId].frames.push(nuevoFrame);
    }
    actualizarLista();
}

function eliminarFrame(frameIndex, escenaId) {
    if (confirm("¬øEliminar este frame?")) {
        escenas[escenaId].frames.splice(frameIndex, 1);
        guardarCambios();
        actualizarLista();
    }
}

function crearBotonEliminarFrame(frameIndex, escenaId) {
    let eliminarFrameBtn = document.createElement("button");
    eliminarFrameBtn.textContent = "‚ùå";
    eliminarFrameBtn.className = "ideframeh2";
    eliminarFrameBtn.onclick = (event) => {
        event.stopPropagation();
        eliminarFrame(frameIndex, escenaId);
    };
    return eliminarFrameBtn;
}

function editarEscena(escenaId) {
    if (!escenas[escenaId]) return;
    console.log("Editando escena:", escenaId);
    // L√≥gica para abrir la vista de edici√≥n de escena si es necesario.
    // Por ahora, el clic principal est√° en los elementos internos.
}

function actualizarLista() {
    let lista = document.getElementById("lista-capitulos");
    lista.innerHTML = "";

    const tituloContainer = document.getElementById('libro-activo-titulo');

    // Si no hay un libro seleccionado, mostrar un mensaje y salir.
    if (!libroActivoId) {
        if (tituloContainer) tituloContainer.textContent = "Selecciona un libro para empezar";
        lista.innerHTML = '<p class="mensaje-placeholder">Usa el bot√≥n "üìö Seleccionar Libro" para empezar.</p>';
        return;
    }

    // MODIFICADO: Filtrar las escenas para mostrar solo las del libro activo
    let escenasDelLibroActivo = Object.keys(escenas).filter(id => escenas[id].libroId === libroActivoId);

    // Ordenar las escenas/cap√≠tulos
    escenasDelLibroActivo.sort();

    if (escenasDelLibroActivo.length === 0) {
        lista.innerHTML = '<p class="mensaje-placeholder">Este libro est√° vac√≠o. Haz clic en el bot√≥n "+" para a√±adir tu primer cap√≠tulo.</p>';
    }

    // El resto de la funci√≥n es casi igual, pero itera sobre la lista filtrada
    escenasDelLibroActivo.forEach(id => {
        // El c√≥digo para crear cada tarjeta de cap√≠tulo (div.escena, inputs, botones, etc.)
        // permanece exactamente igual que antes. Solo lo pegas aqu√≠.
        
        let div = document.createElement("div");
        div.className = "escena";
        // ... (resto de tu c√≥digo para crear la tarjeta del cap√≠tulo) ...
         div.setAttribute("data-id", id);
        div.onclick = () => editarEscena(id);

        let detallediv = document.createElement("div");
        detallediv.className = "detalle";
        let inputNombre = document.createElement("input");
        inputNombre.className = "imput";
        inputNombre.value = escenas[id].texto || `Cap√≠tulo ${id}`; // Texto por defecto
        inputNombre.placeholder = "Nombre del Cap√≠tulo";
        
        // Asignar el nombre al objeto escena cuando el usuario lo cambia
        inputNombre.onchange = (event) => {
            escenas[id].texto = event.target.value;
            guardarCambios(); 
        };

        let eliminarBtn = document.createElement("button");
        eliminarBtn.textContent = "‚ùå";
        eliminarBtn.className = "ide";
        eliminarBtn.onclick = (event) => {
            event.stopPropagation();
            if (confirm("¬øEliminar este cap√≠tulo?")) {
                delete escenas[id];
                guardarCambios();
                actualizarLista();
            }
        };
        let frameBtn = document.createElement("button");
        frameBtn.textContent = "‚ûï üñºÔ∏è";
        frameBtn.className = "ideframe";
        frameBtn.onclick = (event) => {
            event.stopPropagation();
            agregarFrame(id);
        };
        detallediv.appendChild(inputNombre);
        detallediv.appendChild(eliminarBtn);
        detallediv.appendChild(frameBtn);
        div.appendChild(detallediv);

        let contenedorFrames = document.createElement("div");
        // ... y as√≠ sucesivamente hasta el final del bucle.
        
        (escenas[id].frames || []).forEach((frame, index) => {
            let frameDiv = document.createElement("div");
            frameDiv.className = "frameh";
            const textSpan = document.createElement('span');
            textSpan.classList.add('framehtxt');
            textSpan.textContent = ` ${index + 1}`;
            frameDiv.appendChild(textSpan);
            frameDiv.draggable = true;

            // ... (Toda la l√≥gica de drag-and-drop y creaci√≥n de frames) ...
             frameDiv.ondragstart = (event) => {
                draggedFrameIndex = index;
                draggedFrameEscenaId = id;
                event.dataTransfer.setData("text/plain", JSON.stringify({ index, escenaId: id }));
                event.target.style.opacity = 0.5;
            };
            frameDiv.ondragend = (event) => {
                event.target.style.opacity = "";
            };
             frameDiv.ondragover = (event) => {
                event.preventDefault();
                if (draggedFrameEscenaId !== id || index === draggedFrameIndex) return;
                const rect = frameDiv.getBoundingClientRect();
                frameDiv.style.borderLeft = (event.clientX < rect.left + rect.width / 2) ? "3px solid dodgerblue" : "";
                frameDiv.style.borderRight = (event.clientX >= rect.left + rect.width / 2) ? "3px solid dodgerblue" : "";
            };
            frameDiv.ondragleave = (event) => {
                frameDiv.style.borderLeft = "";
                frameDiv.style.borderRight = "";
            };
            frameDiv.ondrop = (event) => {
                event.preventDefault();
                frameDiv.style.borderLeft = "";
                frameDiv.style.borderRight = "";
                const data = JSON.parse(event.dataTransfer.getData("text/plain"));
                if (data.escenaId !== id) return;

                const framesArray = escenas[id].frames;
                const [draggedItem] = framesArray.splice(data.index, 1);
                
                let targetIndex = index;
                if(data.index < index) targetIndex--;

                const rect = frameDiv.getBoundingClientRect();
                const dropIndex = (event.clientX < rect.left + rect.width / 2) ? targetIndex : targetIndex + 1;
                
                framesArray.splice(dropIndex, 0, draggedItem);
                
                guardarCambios();
                actualizarLista();
            };
             let inputTexto = document.createElement("textarea");
            inputTexto.value = frame.texto || "";
            inputTexto.placeholder = "Escribe el texto aqu√≠";
            inputTexto.oninput = (event) => {
                frame.texto = event.target.value;
                guardarCambios();
            };
             let inputImagen = document.createElement("input");
            inputImagen.type = "file";
            inputImagen.accept = "image/*, video/mp4, video/webm, image/gif";
            inputImagen.style.display = 'none';
            inputImagen.id = `fileInput-${id}-${index}`;
            inputImagen.onchange = async (event) => {
                let file = event.target.files[0];
                if (file) {
                    let base64Data = await fileToBase64(file);
                    if (base64Data) {
                        frame.imagen = base64Data;
                        let imagenPreview = frameDiv.querySelector("img");
                        if (imagenPreview) {
                            imagenPreview.src = frame.imagen;
                            imagenPreview.style.display = "block";
                        }
                        guardarCambios();
                    }
                }
            };
             let imagenPreview = document.createElement("img");
            imagenPreview.style.width = "100%";
            imagenPreview.style.height = "auto";
            imagenPreview.style.marginTop = "10px";
            imagenPreview.style.display = frame.imagen ? "block" : "none";
            if (frame.imagen) {
                imagenPreview.src = frame.imagen;
            }
             let label = document.createElement("label");
            label.htmlFor = `fileInput-${id}-${index}`;
            label.className = "custom-label";
            label.textContent = "üì∑";
            label.appendChild(inputImagen);

            let agregarFrameBtn = document.createElement("button");
            agregarFrameBtn.textContent = "+ Frame";
            agregarFrameBtn.className = "ideframeh";
            agregarFrameBtn.onclick = (event) => {
                event.stopPropagation();
                agregarFrame(id, index);
            };
             frameDiv.appendChild(inputTexto);
            frameDiv.appendChild(label);
            frameDiv.appendChild(imagenPreview);
            frameDiv.appendChild(agregarFrameBtn);
            frameDiv.appendChild(crearBotonEliminarFrame(index, id));


            contenedorFrames.appendChild(frameDiv);
        });
         div.appendChild(contenedorFrames);


        lista.appendChild(div);
    });
}   

// A√ëADE ESTA FUNCI√ìN COMPLETA EN EL ARCHIVO datos/escenas.js

/**
 * Crea m√∫ltiples escenas (cap√≠tulos) de forma autom√°tica y las asocia al libro activo.
 * @param {string} nombreBase - El nombre base para los nuevos cap√≠tulos.
 * @param {number} numEscenas - El n√∫mero de cap√≠tulos a crear.
 * @param {number} numFrames - El n√∫mero de frames vac√≠os a crear en cada cap√≠tulo.
 */
function crearEscenasAutomaticamente(nombreBase, numEscenas, numFrames) {
    // 1. Comprobaci√≥n crucial: Asegurarse de que hay un libro activo.
    if (!libroActivoId) {
        alert("Error interno: Se intent√≥ crear cap√≠tulos sin un libro activo seleccionado.");
        return;
    }

    if (!nombreBase || numEscenas <= 0) {
        console.error("Llamada inv√°lida a crearEscenasAutomaticamente: se requiere nombre base y n√∫mero de escenas.");
        return;
    }

    // 2. L√≥gica para crear las escenas en un bucle.
    for (let i = 1; i <= numEscenas; i++) {
        ultimoId++;
            const id = `${libroActivoId}-${nombreBase} ${String(ultimoId).padStart(3, '0')}`;


        // Comprobar si ya existe para evitar sobreescribir.
        if (escenas[id]) {
            console.warn(`La escena con ID ${id} ya exist√≠a. Se omiti√≥ la creaci√≥n.`);
            continue;
        }

        const framesIniciales = [];
        for (let j = 0; j < numFrames; j++) {
            framesIniciales.push({ texto: "", imagen: "" });
        }

        // 3. LA CORRECCI√ìN CLAVE: Asignar el 'libroId' al crear la escena.
        escenas[id] = {
            tipo: "generica",
            texto: id, // El nombre se refinar√° m√°s tarde
            imagen: "",
            opciones: [],
            botones: [],
            frames: framesIniciales,
            generadoPorIA: true,
            libroId: libroActivoId // <--- ¬°AQU√ç EST√Å LA MAGIA!
        };
    }

    console.log(`${numEscenas} escenas creadas con el nombre base "${nombreBase}" y asociadas al libro ID: ${libroActivoId}.`);
    
    // 4. Se guarda y se actualiza la lista para que los cambios sean visibles.
    guardarCambios();
    actualizarLista();
}
function reiniciarContadorEscenas() {
    ultimoId = 0;
    console.log("Contador de escenas (ultimoId) reiniciado a 0.");
}
function guardarCambios() {
    if (typeof(Storage) !== "undefined") {
        try {
            const cleanEscenas = JSON.parse(JSON.stringify(escenas));
            localStorage.setItem("escenas", JSON.stringify(cleanEscenas));
            console.log("Cambios guardados en localStorage.");
        } catch (error) {
            console.error("Error al guardar cambios en localStorage:", error);
        }
    } else {
        console.error("localStorage no est√° disponible en este navegador.");
    }
}

function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = error => reject(error);
        reader.readAsDataURL(file);
    });
}
