// =================================================================
// M√ìDULO DE ANIMACI√ìN SVG - animacionsvg.js (Versi√≥n Sincronizada y Robusta)
// =================================================================
// OBJETIVO: Orquestar la creaci√≥n de animaciones basadas en SVG
// utilizando la IA de Gemini para la planificaci√≥n y reutilizaci√≥n de recursos.
//
// MEJORAS CLAVE:
// 1. SINCRONIZADO CON GENERADOR.JS: La llamada a la API (modelo, API key,
//    y safety settings) es id√©ntica a la del archivo generador.js.
// 2. ESPERA DE API KEY: Se ha a√±adido una funci√≥n que espera a que la
//    API key est√© disponible, evitando errores de tiempo de carga.
// 3. MANEJO DE ERRORES MEJORADO: Se verifica que la respuesta de la IA sea un JSON v√°lido.
// 4. L√ìGICA DE REPRODUCCI√ìN: Sistema robusto para detener y limpiar animaciones.
// =================================================================

document.addEventListener('DOMContentLoaded', () => {
    // Referencias a los elementos de la UI de animacion.html
    const generateBtn = document.getElementById('generate-animation-btn');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const promptTextarea = document.getElementById('animation-prompt');
    const canvasEl = document.getElementById('animation-canvas');

    if (!generateBtn) return; // Salir si no estamos en la p√°gina de animaci√≥n correcta

    // --- CONFIGURACI√ìN DEL CANVAS ---
    const CANVAS_WIDTH = 1280;
    const CANVAS_HEIGHT = 720;
    canvasEl.width = CANVAS_WIDTH;
    canvasEl.height = CANVAS_HEIGHT;

    const fabricCanvas = new fabric.Canvas(canvasEl, {
        width: CANVAS_WIDTH,
        height: CANVAS_HEIGHT,
        backgroundColor: '#1e1e1e',
        selection: false // Deshabilitar selecci√≥n de grupo con el rat√≥n
    });

    let animationPlan = null; // Aqu√≠ guardaremos el plan de la IA
    let isPlaying = false;
    let animationTimeouts = []; // Almacena los IDs de los setTimeout para poder detenerlos

    /**
     * Espera a que la variable global 'apiKey' est√© disponible.
     * @returns {Promise<string>} La clave de la API.
     */
    function getApiKey() {
        return new Promise((resolve, reject) => {
            let attempts = 0;
            const maxAttempts = 50; // Espera hasta 5 segundos
            const interval = setInterval(() => {
                // 'apiKey' es la variable global que se espera que cargue otro script (como io.js)
                if (typeof apiKey !== 'undefined' && apiKey) {
                    clearInterval(interval);
                    resolve(apiKey);
                } else {
                    attempts++;
                    if (attempts > maxAttempts) {
                        clearInterval(interval);
                        reject(new Error("Tiempo de espera agotado para encontrar la API Key. Aseg√∫rate de que la variable global 'apiKey' se est√° cargando correctamente."));
                    }
                }
            }, 100);
        });
    }


    // --- EVENT LISTENERS ---
    generateBtn.addEventListener('click', handleGenerateAnimation);
    playPauseBtn.addEventListener('click', handlePlayPause);

    /**
     * Llama a la API de Gemini para crear un plan de animaci√≥n en formato JSON.
     * @param {string} userPrompt - La descripci√≥n de la animaci√≥n solicitada por el usuario.
     * @param {Array} personajesDisponibles - Array de objetos de los personajes existentes.
     * @returns {Promise<object>} El plan de animaci√≥n en formato JSON.
     */
    async function generarPlanDeAnimacion(userPrompt, personajesDisponibles) {
        console.log("ü§ñ Creando prompt para la IA...");

        const personajesParaPrompt = personajesDisponibles.map(p =>
            `- Nombre: "${p.nombre}", Descripci√≥n: "${p.descripcion}", svgContent: '${p.svgContent}'`
        ).join('\n');

        const systemPrompt = `
Eres un experto director de animaci√≥n que crea planes de animaci√≥n para Fabric.js.
Tu √∫nica tarea es devolver un objeto JSON v√°lido basado en la petici√≥n del usuario y los recursos disponibles. No incluyas texto explicativo, solo el JSON.

El canvas tiene un tama√±o de ${CANVAS_WIDTH}x${CANVAS_HEIGHT} p√≠xeles.

El JSON debe tener la siguiente estructura:
{
  "personajes": [
    {
      "nombre": "nombre_del_personaje_a_usar",
      "svgContent": "<svg>...</svg>",
      "posicionInicial": { "x": number, "y": number, "width": number, "angulo": number }
    }
  ],
  "eventos": [
    {
      "tiempo": number,
      "target": "nombre_del_personaje_o_camara",
      "animacion": {
        "left": number, "top": number, "angle": number,
        "duracion": number, "ease": "string"
      }
    }
  ]
}

REGLAS IMPORTANTES:
1.  Utiliza SOLAMENTE los personajes de la lista proporcionada.
2.  Para cada personaje en la secci√≥n "personajes" del JSON, DEBES incluir su "svgContent" completo.
3.  Las coordenadas (left, top) deben estar dentro del canvas (${CANVAS_WIDTH}x${CANVAS_HEIGHT}).
4.  Crea una secuencia de eventos ("eventos") l√≥gica y que dure varios segundos.
5.  Puedes animar la "camara" con la propiedad "zoom".
6.  Responde √∫nicamente con el objeto JSON. No uses bloques de c√≥digo markdown (\`\`\`json).
`;

        const fullPrompt = `
Petici√≥n del usuario: "${userPrompt}"

Personajes disponibles:
${personajesParaPrompt || "No hay personajes disponibles. Crea uno si es necesario."}

Genera el plan de animaci√≥n en formato JSON siguiendo todas las reglas.
`;

        try {
            console.log("Esperando API key y enviando petici√≥n a Gemini...");
            
            const aKey = await getApiKey();
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${aKey}`;

            const payload = {
                contents: [{ parts: [{ text: systemPrompt + fullPrompt }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                },
                safetySettings: [
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
                ]
            };

            const response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`Error en la API de Gemini: ${response.statusText}. Detalles: ${errorBody}`);
            }

            const result = await response.json();
            
            if (!result.candidates || result.candidates.length === 0) {
                throw new Error("La respuesta de la IA no contiene 'candidates'.");
            }
            
            const jsonText = result.candidates[0].content.parts[0].text;
            
            try {
                return JSON.parse(jsonText);
            } catch (parseError) {
                console.error("Error al parsear el JSON de la IA. Respuesta recibida:", jsonText);
                throw new Error("La respuesta de la IA no es un JSON v√°lido.");
            }

        } catch (error) {
            console.error("‚ùå Error al contactar con la IA:", error);
            throw error;
        }
    }


    /**
     * Orquesta todo el proceso de generaci√≥n de la animaci√≥n.
     */
    async function handleGenerateAnimation() {
        const userPrompt = promptTextarea.value.trim();
        if (!userPrompt) {
            alert("Por favor, describe la animaci√≥n que deseas crear.");
            return;
        }

        generateBtn.disabled = true;
        generateBtn.textContent = 'Generando...';
        detenerAnimacion();

        try {
            const personajesDisponibles = obtenerDatosCompletosDelDOM();
            console.log("Personajes disponibles enviados a la IA:", personajesDisponibles);

            animationPlan = await generarPlanDeAnimacion(userPrompt, personajesDisponibles);

            console.log("‚úÖ Plan de animaci√≥n recibido de la IA:", JSON.stringify(animationPlan, null, 2));

            if (animationPlan && animationPlan.personajes) {
                cargarEscena(animationPlan);
            } else {
                throw new Error("La respuesta de la IA no tiene el formato esperado (falta la clave 'personajes').");
            }

        } catch (error) {
            console.error("‚ùå Error al generar la animaci√≥n:", error);
            alert(`Hubo un error al generar el plan de animaci√≥n: ${error.message}. Revisa la consola para m√°s detalles.`);
        } finally {
            generateBtn.disabled = false;
            generateBtn.textContent = 'Generar Animaci√≥n';
        }
    }

    /**
     * Carga los personajes y su estado inicial en el canvas.
     * @param {object} plan - El plan de animaci√≥n generado por la IA.
     */
    function cargarEscena(plan) {
        fabricCanvas.clear();
        if (!plan || !plan.personajes) {
            console.error("El plan de animaci√≥n es inv√°lido o no contiene personajes.");
            return;
        }

        plan.personajes.forEach(personaje => {
            if (personaje.svgContent) {
                fabric.loadSVGFromString(personaje.svgContent, (objects, options) => {
                    const group = new fabric.Group(objects, {
                        data: { nombre: personaje.nombre }
                    });

                    const pos = personaje.posicionInicial || {};
                    const targetWidth = pos.width || 200;
                    
                    group.scaleToWidth(targetWidth);

                    group.set({
                        left: pos.x || CANVAS_WIDTH / 2,
                        top: pos.y || CANVAS_HEIGHT / 2,
                        angle: pos.angulo || 0,
                        originX: 'center',
                        originY: 'center'
                    });

                    fabricCanvas.add(group);
                    fabricCanvas.renderAll();
                });
            } else {
                 console.warn(`El personaje "${personaje.nombre}" no tiene svgContent para ser cargado.`);
            }
        });
        fabricCanvas.setZoom(1);
        fabricCanvas.absolutePan({ x: 0, y: 0 });
    }

    /**
     * Gestiona el bot√≥n de Play/Pause.
     */
    function handlePlayPause() {
        isPlaying = !isPlaying;
        playPauseBtn.textContent = isPlaying ? 'Detener' : 'Reproducir';

        if (isPlaying) {
            if (animationPlan) {
                reproducirAnimacion(animationPlan);
            } else {
                alert("Primero debes generar una animaci√≥n.");
                isPlaying = false;
                playPauseBtn.textContent = 'Reproducir';
            }
        } else {
            detenerAnimacion();
        }
    }

    /**
     * Detiene todos los timeouts de animaci√≥n y resetea el estado.
     */
    function detenerAnimacion() {
        console.log("üõë Deteniendo animaci√≥n...");
        animationTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
        animationTimeouts = [];
        
        if (animationPlan) {
            cargarEscena(animationPlan);
        }

        isPlaying = false;
        playPauseBtn.textContent = 'Reproducir';
    }


    /**
     * Itera sobre los eventos del plan y los ejecuta con timeouts.
     * @param {object} plan - El plan de animaci√≥n.
     */
    function reproducirAnimacion(plan) {
        console.log("‚ñ∂Ô∏è Reproduciendo animaci√≥n con el plan:", plan);
        if (!plan.eventos || plan.eventos.length === 0) {
            console.warn("‚ö†Ô∏è El plan no contiene eventos de animaci√≥n para reproducir.");
            detenerAnimacion();
            return;
        }

        cargarEscena(plan);

        plan.eventos.forEach(evento => {
            const timeoutId = setTimeout(() => {
                console.log(`‚è∞ Evento [${evento.tiempo}ms] -> Target: ${evento.target}`);
                
                const targetObject = fabricCanvas.getObjects().find(obj => obj.data && obj.data.nombre === evento.target);

                if (targetObject) {
                    console.log(`   üéØ Objeto encontrado: "${evento.target}". Animando con:`, evento.animacion);
                    
                    const animProps = { ...evento.animacion };
                    const duration = Number(animProps.duracion) || 1000;
                    const ease = animProps.ease || 'easeOutQuad';
                    
                    delete animProps.duracion;
                    delete animProps.ease;

                    targetObject.animate(animProps, {
                        duration: duration,
                        onChange: fabricCanvas.renderAll.bind(fabricCanvas),
                        onComplete: () => {
                            console.log(`   ‚úÖ Animaci√≥n completada para "${evento.target}"`);
                        },
                        easing: fabric.util.ease[ease]
                    });

                } else if (evento.target === 'camara') {
                    console.log(`   üé• Animando c√°mara:`, evento.animacion);
                    const { zoom, duracion } = evento.animacion;
                    fabricCanvas.zoomToPoint(
                        new fabric.Point(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2),
                        zoom,
                        {
                           duration: duracion || 1000,
                           onChange: fabricCanvas.renderAll.bind(fabricCanvas),
                           onComplete: () => console.log('   ‚úÖ Animaci√≥n de c√°mara completada')
                        }
                    );

                } else {
                    console.warn(`   ‚ùì No se encontr√≥ el objeto target en el canvas: "${evento.target}"`);
                }
            }, evento.tiempo);

            animationTimeouts.push(timeoutId);
        });
    }

    /**
     * Obtiene los datos de los personajes del DOM.
     * @returns {Array} - Un array de objetos de personaje.
     */
    function obtenerDatosCompletosDelDOM() {
        const datos = [];
        document.querySelectorAll('#listapersonajes .personaje').forEach(el => {
            const nombre = el.querySelector('.nombreh')?.value;
            if (nombre) {
                 datos.push({
                    nombre: nombre,
                    descripcion: el.querySelector('textarea')?.value || '',
                    svgContent: el.dataset.svgContent || '',
                    imagen: el.querySelector('.personaje-visual img')?.src || ''
                });
            }
        });
        return datos;
    }
});
